## 基本语法

### 1.  Optional

"Hey I might not have a value here, so you have to be prepared to handler that situation.”

Optional are really intended to **only be used as a return type**, where without optional, your method has the possibility on returning null.

```java
private static Optional<Cat> findCatByName(String name) {
    Cat cat = new Cat(name, 3);
    return Optional.ofNullable(cat);
}

private static Optional<Cat> findCatByName(String name) {
    Cat cat = new Cat(name, 3);
    return Optional.empty();
}
```

```java
public static void main(String[] args) {
    Optional<Cat> optionalCat = findCatByName("Fred");
    
    optionalCat.get(); // return the value that insides the optional
    // optional里为空时，get()会NoSuchElementException
    optionalCat.isPresent();
    optionalCat.orElse(new Cat("UNKNOWN", 0)); // 括号里是empty时的default
    optionalCat.orElseGet(); // 括号里是supplier，lambda表达式
    optionalCat.orElseThrow(); // get()的替代

    optionalCat.map(Cat::getAge) // take cat optional and transform into an optional of another type
        .orElse(0); 
}
```

### 2. Streams

```java
List<Person> people = getPeople();
```

```java
// Imperative approach
List<Person> females = new ArrayList<>();
for (Person person : people) {
    if (person.getGender().equals(Gender.FEMALE)) {
        female.add(person);
    }
}
females.forEach(System.out::println);
```

```java
// Declarative approach - Filter
List<Person> females = people.stream()
    .filter(person -> person.getGender().equals(Gender.FEMALE)) // filter takes a predicate, which simply returns true or false
    .collect(Collectors.toList());
```

```java
// Declarative approach - Sort
List<Person> sorted = people.stream()
    .sorted(Comparator.comparing(Person::getAge))
    .collect(Collectors.toList());

List<Person> sorted = people.stream()
    .sorted(Comparator.comparing(Person::getAge).reversed())
    .collect(Collectors.toList());

List<Person> sorted = people.stream()
    .sorted(Comparator.comparing(Person::getAge).thenComparing(Person::getGender).reversed())
    .collect(Collectors.toList());
```

```java
// Declarative approach - All match
boolean allMatch = people.stream()
    .allMatch(person -> person.getAge() > 5);

// Any match
boolean allMatch = people.stream()
    .anyMatch(person -> person.getAge() > 5);

// None match
boolean noneMatch = people.stream()
    .noneMatch(person -> person.getName().equals("Antonio"));
```

```java
// Declarative approach - Max
people.stream()
    .max(Comparator.comparing(Person::getAge))
    .ifPresent(System.out::println);

// Declarative approach - Min
people.stream()
    .min(Comparator.comparing(Person::getAge))
    .ifPresent(System.out::println);
```

```java
// Declarative approach - Group
Map<Gender, List<Person>> groupByGender = people.stream()
    .collect(Collectors.groupingBy(Person::getGender));
groupByGender.forEach((gender, people1) -> {
    System.out.println(gender);
    people1.forEach(System.out::println);
})
```

```java
Optional<String> oldestFemaleAge = people.stream()
    .filter(person -> person.getGender().equals(Gender.FEMALE))
    .max(Comparator.comparing(Person::getAge))
    .map(Person::getName);
oldestFemaleAge.ifPresent(System.out::println);
```



